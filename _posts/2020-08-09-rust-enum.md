# 铁锈语言之枚举

* [定义枚举和枚举值](#定义枚举和枚举值)
    * [普通枚举值](#普通枚举值)
    * [内涵枚举值](#内涵枚举值)
    * [枚举值的比较](#枚举值的比较)
* [高级应用](#高级应用)
    * [定义枚举类型的行为](#定义枚举类型的行为)

## 定义枚举和枚举值

### 普通枚举值

铁锈语言的枚举类型看起来和其它编程语言的没什么不同：
```rust
enum IpAddrKind {
    V4,
    V6,
}
```
这段代码定义了一个名为 `IpAddrKind` 的枚举类型，并且定义了这个类型仅有的两个枚举值：`V4` 和 `V6`。要注意这里 `V4`，`V6` 不是变量，而是值。而且这两个值既不是整型，也不是字符串，更不是什么别的类型，它的类型就是程序员自定义的 `IpAddrKind`。通过定义这个枚举类型，程序员拓展了铁锈语言的类型系统。

这两个枚举值没有什么其它特殊的地方，称之为 _普通枚举值_。

既然是值，可以用变量承载它们：
```rust
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
```

也可以让函数接受这种类型的参数：
```rust
fn route(ip_kind: IpAddrKind) {}
```

调用的时候就是传入上述自定义的两个枚举值中的某一个：
```rust
route(IpAddrKind::V4); // 传入字面量
route(six);            // 传入变量
```
同理，该枚举类型也可以用于声明结构体的字段类型等，不再赘述。

### 内涵枚举值

在定义枚举值的时候，可以在枚举值定义后面加上个括号，里面写上某个类型名称，用来绑定某个 **已存在** 类型：
```rust
enum IpAddr {
    V4(String),
    V6(String),
}
```

上述代码 `V4` 和 `V6` 两个枚举值都绑定了字符串作为各自的内嵌类型。这就好像在金本位规则下，各国给印刷的货币绑定含金量一样，程序员凭空创造的枚举值用其它类型的值作为标的物。该类型枚举值必须通过 `枚举类型::枚举值(内嵌类型值)` 形式构造：
```rust
let home = IpAddr::V4(String::from("127.0.0.1"));
let loopback = IpAddr::V6(String::from("::1"));
```

> ⚠️ 调皮的你是否想问能不能绑定 `IpAddr` 枚举类型作为它自己某个枚举值的内嵌数据类型？简单来说是不可以的，因为编译器要求该类型是编译时已知的类型。
这个问题我们可以在未来专门讨论。
> ```rust
> enum MyEnum {
>    A,
>    B(MyEnum),
> }
>
> let b = MyEnum::B(MyEnum::A);
> ```
> ```
> error[E0072]: recursive type `MyEnum` has infinite size
> --> src/main.rs:2:1
>   |
> 2 | enum MyEnum {
>   | ^^^^^^^^^^^ recursive type has infinite size
> 3 |     A,
> 4 |     B(MyEnum),
>   |       ------ recursive without indirection
> ```

同一个枚举类型，其不同的枚举值可以绑定不同的内嵌数据类型：
```rust
enum IpAddr {
    Unknown,            // 不绑任何类型
    V4(u8, u8, u8, u8), // 绑定一个由4个 `u8` 组成的元组
    V6(String),         // 绑定字符串
    V999(SomeStruct),   // 绑定某个结构体
}

let home = IpAddr::V4(127, 0, 0, 1);
let loopback = IpAddr::V6(String::from("::1"));
```

### 枚举值的比较

> 这里说的“比较”，指的是通过 `==` 号进行的相等判定。由于枚举类型是程序员自定义的类型，其行为也应当由程序员自定义。因此铁锈语言对枚举类型并没有实现统一的 `std::cmp::PartialEq` 特性。就是说默认情况下，某枚举类型的两个变量无法直接通过 `==` 判断是否相等。
>
> 下文描述的比较行为，是通过加注解，让编译器加上了实现 `std::cmp::PartialEq` 的默认代码。

对于 _没有绑定值_ 的平凡枚举类型，如果两个变量它们值的字面量相同，则它们相等：
```rust
#[derive(Debug, PartialEq)]
enum MyEnum {
    A,
}

let a1 = MyEnum::A;
let a2 = MyEnum::A;
assert_eq!(a1, a2);
```
这个道理比较简单，无需赘述。唯一需要说明的是，这里的代码为了使用 `assert_eq!()` 宏来比较两个变量，要求变量类型需实现 `std::fmt::Debug` 和 `std::cmp::PartialEq` 两个特性。
这两个特性较为常用，铁锈语言可以通过加注解的方式，由编译器在编译时为我们这个类型加上模版代码，以简单的、默认的行为实现这两个特性（~~懒人福音~~）。


对于 _有内涵的_ 枚举类值，其比较方式基本类似。本质上都是调用该类型的 `std:cmp::PartialEq` 特性的实现方法来进行比较。不同的是，如果比较的双方含有绑定的数据类型，则还需要调用该内嵌类型的 `std::cmp::PartialEq` 方法进行判定：
```rust
#[derive(Debug, PartialEq)]
enum MyEnum {
    A(String),
}

let a1 = MyEnum::A(String::from("A1"));
let a2 = MyEnum::A(String::from("A2"));
assert_eq!(a1, a2);
```
因为其内嵌的字符串并不相等，所以断言会失败：
```
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `A("A1")`,
 right: `A("A2")`', src/main.rs:9:5
```

另外显而易见的是，如果枚举值不同，即使内嵌值相等，比较的枚举变量也不相等：
```rust
#[derive(Debug, PartialEq)]
enum MyEnum {
    A(String),
    B(String),
}

let a = MyEnum::A(String::from("same"));
let b = MyEnum::B(String::from("same"));
assert_eq!(a, b);
```

断言失败：
```
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `A("same")`,
 right: `B("same")`', src/main.rs:10:5
```

这种行为深究的话，应该是编译器在加上模版代码的时候，对内嵌类型也做了比较（没准嵌套地加上了 `#[derive(PartialEq)]`）。

当然这种比较行为是编译器编译时添加代码实现的默认行为，程序员可以自定义实现不同的比较逻辑。

## 高级应用

### 定义枚举类型的行为

同样作为自定义的类型，枚举类型和结构体一样，也可以定义行为：
```rust
#[derive(Debug)]
enum MyEnum {
    A,
    B,
}

impl MyEnum {
    fn call(&self) {
        println!("{:?}", self);
    }
}
```

这样所有 `MyEnum` 的枚举值都可以调用该行为逻辑：
```rust
let a = MyEnum::A;
let b = MyEnum::B;
a.call();
b.call();
```

看下面这个内涵枚举类型定义：
```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

这里面 `Message::Move` 这个枚举值绑定了一个 **匿名** 结构体。它的值的构造方法：
```rust
let m = Message::Move { x: 1, y: 2 };
```

> 这 `Message::Move` 看起来用法和结构体一样，只不过 `m` 是一个枚举类型 `Message` 的变量。
